// Generated by CoffeeScript 1.8.0
(function() {
  window.Visualizer = (function() {
    Visualizer.prototype.keys = {
      PAUSE: 32,
      NEXT: 78
    };

    function Visualizer(scene, camera) {
      this.viewer = new VisualizerViewer(scene, camera);
      window.AudioContext = window.AudioContext || window.webkitAudioContext;
      this.audioContext = new AudioContext();
      this.audioWindow = new AudioWindow(2048, 1);
      this.loadedAudio = new Array();
      this.analyser = this.audioContext.createAnalyser();
      this.analyser.fftSize = 2048;
      this.startOffset = 0;
      this.play('audio/Go.mp3');
      this.choreographyRoutine = new ChoreographyRoutine(this);
      this.setupGUI();
      this.choreographyRoutine.playNext();
      $('#viewerButton').click((function(_this) {
        return function(e) {
          var popupURL, sendBeats;
          e.preventDefault();
          _this.domain = window.location.protocol + '//' + window.location.host;
          popupURL = _this.domain + '/viewer.html';
          _this.popup = window.open(popupURL, 'myWindow');
          sendBeats = function() {
            var routineBeat, _results;
            routineBeat = _this.choreographyRoutine.routineBeat;
            _this.choreographyRoutine.routineBeat = -1;
            _results = [];
            while (_this.choreographyRoutine.routineBeat < routineBeat) {
              _results.push(_this.choreographyRoutine.playNext());
            }
            return _results;
          };
          return setTimeout(sendBeats, 100);
        };
      })(this));
    }

    Visualizer.prototype.setupGUI = function() {
      var danceController, danceFolder, danceMaterialController, danceMaterialFolder, dancerController, dancerFolder, gui, idController, updateDanceFolder, updateDanceMaterialFolder, updateDancerFolder;
      gui = new dat.GUI();
      gui.add(this.audioWindow, 'responsiveness', 0.0, 5.0);
      idController = gui.add(this.choreographyRoutine, 'id');
      dancerController = gui.add(this.choreographyRoutine, 'dancer', Object.keys(Visualizer.dancerTypes));
      dancerFolder = gui.addFolder('Dancer parameters');
      dancerFolder.open();
      updateDancerFolder = (function(_this) {
        return function(value, obj) {
          var param, _i, _len, _ref, _ref1, _results;
          if (Visualizer.dancerTypes[value] == null) {
            return;
          }
          while (dancerFolder.__controllers[0] != null) {
            dancerFolder.remove(dancerFolder.__controllers[0]);
          }
          _ref = Visualizer.dancerTypes[value].params;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            param = _ref[_i];
            _this.choreographyRoutine.dancerParams[param.name] = (obj != null ? (_ref1 = obj.options) != null ? _ref1[param.name] : void 0 : void 0) ? obj.options[param.name] : param["default"];
            _results.push(dancerFolder.add(_this.choreographyRoutine.dancerParams, param.name));
          }
          return _results;
        };
      })(this);
      dancerController.onFinishChange(updateDancerFolder);
      danceController = gui.add(this.choreographyRoutine, 'dance', Object.keys(Visualizer.danceTypes));
      danceFolder = gui.addFolder('Dance parameters');
      danceFolder.open();
      updateDanceFolder = (function(_this) {
        return function(value, obj) {
          var param, _i, _len, _ref, _ref1, _results;
          if (Visualizer.danceTypes[value] == null) {
            return;
          }
          while (danceFolder.__controllers[0] != null) {
            danceFolder.remove(danceFolder.__controllers[0]);
          }
          _ref = Visualizer.danceTypes[value].params;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            param = _ref[_i];
            _this.choreographyRoutine.danceParams[param.name] = (obj != null ? (_ref1 = obj.options) != null ? _ref1[param.name] : void 0 : void 0) ? obj.options[param.name] : param["default"];
            _results.push(danceFolder.add(_this.choreographyRoutine.danceParams, param.name));
          }
          return _results;
        };
      })(this);
      danceController.onChange(updateDanceFolder);
      danceMaterialController = gui.add(this.choreographyRoutine, 'danceMaterial', Object.keys(Visualizer.danceMaterialTypes));
      danceMaterialFolder = gui.addFolder('Dance material parameters');
      danceMaterialFolder.open();
      updateDanceMaterialFolder = (function(_this) {
        return function(value, obj) {
          var param, _i, _len, _ref, _ref1, _results;
          if (Visualizer.danceMaterialTypes[value] == null) {
            return;
          }
          while (danceMaterialFolder.__controllers[0] != null) {
            danceMaterialFolder.remove(danceMaterialFolder.__controllers[0]);
          }
          _ref = Visualizer.danceMaterialTypes[value].params;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            param = _ref[_i];
            _this.choreographyRoutine.danceMaterialParams[param.name] = (obj != null ? (_ref1 = obj.options) != null ? _ref1[param.name] : void 0 : void 0) ? obj.options[param.name] : param["default"];
            _results.push(danceMaterialFolder.add(_this.choreographyRoutine.danceMaterialParams, param.name));
          }
          return _results;
        };
      })(this);
      danceMaterialController.onChange(updateDanceMaterialFolder);
      idController.onChange((function(_this) {
        return function(value) {
          var controller, idDancer, _i, _len, _ref;
          idDancer = _this.viewer.getDancer(value);
          if (idDancer != null) {
            _this.choreographyRoutine.updateDancer(idDancer);
            _ref = gui.__controllers;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              controller = _ref[_i];
              controller.updateDisplay();
            }
            updateDancerFolder(_this.choreographyRoutine.dancer, idDancer);
            updateDanceMaterialFolder(_this.choreographyRoutine.danceMaterial, idDancer.danceMaterial);
            return updateDanceFolder(_this.choreographyRoutine.dance, idDancer.dance);
          }
        };
      })(this));
      gui.add(this.choreographyRoutine, 'preview');
      gui.add(this.choreographyRoutine, 'add');
      gui.add(this.choreographyRoutine, 'insertBeat');
      gui.add(this.choreographyRoutine, 'playNext');
      return gui.add(this.choreographyRoutine, 'reset');
    };

    Visualizer.prototype.receiveChoreography = function(move) {
      return this.viewer.receiveChoreography(move);
    };

    Visualizer.prototype.sendChoreography = function(move) {
      if (this.popup != null) {
        return this.popup.postMessage(this.wrapMessage('choreography', move), this.domain);
      }
    };

    Visualizer.prototype.render = function() {
      if (!this.playing) {
        return;
      }
      this.audioWindow.update(this.analyser, this.audioContext.currentTime);
      this.viewer.render(this.audioWindow);
      if (this.popup != null) {
        return this.popup.postMessage(this.wrapMessage('render', this.audioWindow), this.domain);
      }
    };

    Visualizer.prototype.wrapMessage = function(type, data) {
      return {
        type: type,
        data: data
      };
    };

    Visualizer.prototype.onKeyDown = function(event) {
      switch (event.keyCode) {
        case this.keys.PAUSE:
          if (this.playing) {
            return this.pause();
          } else {
            return this.play(this.currentlyPlaying);
          }
          break;
        case this.keys.NEXT:
          return this.choreographyRoutine.playNext();
      }
    };

    Visualizer.dancerTypes = {
      CubeDancer: CubeDancer,
      SphereDancer: SphereDancer,
      PointCloudDancer: PointCloudDancer
    };

    Visualizer.danceTypes = {
      ScaleDance: ScaleDance,
      PositionDance: PositionDance,
      RotateDance: RotateDance
    };

    Visualizer.danceMaterialTypes = {
      ColorDanceMaterial: ColorDanceMaterial,
      SimpleFrequencyShader: SimpleFrequencyShader
    };

    Visualizer.prototype.pause = function() {
      this.source.stop();
      this.playing = false;
      return this.startOffset += this.audioContext.currentTime - this.startTime;
    };

    Visualizer.prototype.createLiveInput = function() {
      var gotStream;
      gotStream = (function(_this) {
        return function(stream) {
          _this.playing = true;
          _this.source = _this.audioContext.createMediaStreamSource(stream);
          return _this.source.connect(_this.analyser);
        };
      })(this);
      this.dbSampleBuf = new Uint8Array(2048);
      if (navigator.getUserMedia) {
        return navigator.getUserMedia({
          audio: true
        }, gotStream, function(err) {
          return console.log(err);
        });
      } else if (navigator.webkitGetUserMedia) {
        return navigator.webkitGetUserMedia({
          audio: true
        }, gotStream, function(err) {
          return console.log(err);
        });
      } else if (navigator.mozGetUserMedia) {
        return navigator.mozGetUserMedia({
          audio: true
        }, gotStream, function(err) {
          return console.log(err);
        });
      } else {
        return alert("Error: getUserMedia not supported!");
      }
    };

    Visualizer.prototype.play = function(url) {
      var request;
      this.currentlyPlaying = url;
      if (this.loadedAudio[url] != null) {
        this.loadFromBuffer(this.loadedAudio[url]);
        return;
      }
      request = new XMLHttpRequest();
      request.open("GET", url, true);
      request.responseType = 'arraybuffer';
      request.onload = (function(_this) {
        return function() {
          _this.audioContext.decodeAudioData(request.response, function(buffer) {
            _this.loadedAudio[url] = buffer;
            return _this.loadFromBuffer(buffer);
          }, function(err) {
            return console.log(err);
          });
        };
      })(this);
      request.send();
    };

    Visualizer.prototype.loadFromBuffer = function(buffer) {
      this.startTime = this.audioContext.currentTime;
      this.source = this.audioContext.createBufferSource();
      this.source.buffer = buffer;
      this.source.connect(this.analyser);
      this.source.connect(this.audioContext.destination);
      this.playing = true;
      return this.source.start(0, this.startOffset);
    };

    return Visualizer;

  })();

}).call(this);
