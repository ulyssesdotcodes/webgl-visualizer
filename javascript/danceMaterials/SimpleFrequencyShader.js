// Generated by CoffeeScript 1.8.0
(function() {
  window.SimpleFrequencyShader = (function() {
    function SimpleFrequencyShader(shaderLoader) {
      this.shaderLoader = shaderLoader;
    }

    SimpleFrequencyShader.prototype.loadShader = function(audioWindow, next) {
      return this.shaderLoader.load('simple_frequency', (function(_this) {
        return function(shader) {
          shader.uniforms = {
            freqTexture: {
              type: "t",
              value: _this.reduceArray(audioWindow.frequencyBuffer)
            },
            resolution: {
              type: "v2",
              value: new THREE.Vector2(128, 128)
            }
          };
          _this.material = new THREE.ShaderMaterial(shader);
          return next(_this);
        };
      })(this));
    };

    SimpleFrequencyShader.prototype.update = function(audioWindow, dancer) {
      return dancer.body.material.uniforms.freqTexture.value = this.reduceArray(audioWindow.frequencyBuffer);
    };

    SimpleFrequencyShader.prototype.reduceArray = function(freqBuf) {
      var flooredRatio, i, j, movingSum, newBuf, newTexArray, size, target, texture, _i, _j, _k;
      target = 64;
      size = 2048;
      newBuf = new Array(target);
      movingSum = 0;
      flooredRatio = Math.floor(size / target);
      for (i = _i = 1; 1 <= size ? _i <= size : _i >= size; i = 1 <= size ? ++_i : --_i) {
        movingSum += freqBuf[i];
        if (((i + 1) % flooredRatio) === 0) {
          newBuf[Math.floor(i / flooredRatio)] = movingSum / flooredRatio;
          movingSum = 0;
        }
      }
      newTexArray = new Uint8Array(target * target * 4);
      for (i = _j = 0; 0 <= target ? _j <= target : _j >= target; i = 0 <= target ? ++_j : --_j) {
        for (j = _k = 0; 0 <= target ? _k <= target : _k >= target; j = 0 <= target ? ++_k : --_k) {
          if (newBuf[j] < i * 4) {
            newTexArray[i * target + j * 4] = 255;
            newTexArray[i * target + j * 4 + 1] = 255;
            newTexArray[i * target + j * 4 + 2] = 255;
            newTexArray[i * target + j * 4 + 3] = 255;
          } else {
            newTexArray[i * target + j * 4] = 0;
            newTexArray[i * target + j * 4 + 1] = 0;
            newTexArray[i * target + j * 4 + 2] = 0;
            newTexArray[i * target + j * 4 + 3] = 0;
          }
        }
      }
      texture = new THREE.DataTexture(newTexArray, target, target, THREE.RGBAFormat, THREE.UnsignedByte);
      texture.needsUpdate = true;
      return texture;
    };

    return SimpleFrequencyShader;

  })();

}).call(this);
